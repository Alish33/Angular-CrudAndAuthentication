import { dirname, relative, resolve } from 'path';
import * as ts from 'typescript';
import { parseTsconfigFile } from './parse_tsconfig';
/**
 * Creates a TypeScript program instance for a TypeScript project within
 * the virtual file system tree.
 * @param tree Virtual file system tree that contains the source files.
 * @param tsconfigPath Virtual file system path that resolves to the TypeScript project.
 * @param basePath Base path for the virtual file system tree.
 * @param fakeFileRead Optional file reader function. Can be used to overwrite files in
 *   the TypeScript program, or to add in-memory files (e.g. to add global types).
 * @param additionalFiles Additional file paths that should be added to the program.
 */
export function createMigrationProgram(tree, tsconfigPath, basePath, fakeFileRead, additionalFiles) {
    // Resolve the tsconfig path to an absolute path. This is needed as TypeScript otherwise
    // is not able to resolve root directories in the given tsconfig. More details can be found
    // in the following issue: https://github.com/microsoft/TypeScript/issues/37731.
    tsconfigPath = resolve(basePath, tsconfigPath);
    const parsed = parseTsconfigFile(tsconfigPath, dirname(tsconfigPath));
    const host = createMigrationCompilerHost(tree, parsed.options, basePath, fakeFileRead);
    const program = ts.createProgram(parsed.fileNames.concat(additionalFiles || []), parsed.options, host);
    return { parsed, host, program };
}
export function createMigrationCompilerHost(tree, options, basePath, fakeRead) {
    const host = ts.createCompilerHost(options, true);
    const defaultReadFile = host.readFile;
    // We need to overwrite the host "readFile" method, as we want the TypeScript
    // program to be based on the file contents in the virtual file tree. Otherwise
    // if we run multiple migrations we might have intersecting changes and
    // source files.
    host.readFile = fileName => {
        var _a;
        const treeRelativePath = relative(basePath, fileName);
        let result = fakeRead === null || fakeRead === void 0 ? void 0 : fakeRead(treeRelativePath);
        if (result === undefined) {
            // If the relative path resolved to somewhere outside of the tree, fall back to
            // TypeScript's default file reading function since the `tree` will throw an error.
            result = treeRelativePath.startsWith('..') ? defaultReadFile.call(host, fileName) :
                (_a = tree.read(treeRelativePath)) === null || _a === void 0 ? void 0 : _a.toString();
        }
        // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset,
        // which breaks the CLI UpdateRecorder.
        // See: https://github.com/angular/angular/pull/30719
        return result ? result.replace(/^\uFEFF/, '') : undefined;
    };
    return host;
}
/**
 * Checks whether a file can be migrate by our automated migrations.
 * @param basePath Absolute path to the project.
 * @param sourceFile File being checked.
 * @param program Program that includes the source file.
 */
export function canMigrateFile(basePath, sourceFile, program) {
    // We shouldn't migrate .d.ts files or files from an external library.
    if (sourceFile.isDeclarationFile || program.isSourceFileFromExternalLibrary(sourceFile)) {
        return false;
    }
    // Our migrations are set up to create a `Program` from the project's tsconfig and to migrate all
    // the files within the program. This can include files that are outside of the Angular CLI
    // project. We can't migrate files outside of the project, because our file system interactions
    // go through the CLI's `Tree` which assumes that all files are within the project. See:
    // https://github.com/angular/angular-cli/blob/0b0961c9c233a825b6e4bb59ab7f0790f9b14676/packages/angular_devkit/schematics/src/tree/host-tree.ts#L131
    return !relative(basePath, sourceFile.fileName).startsWith('..');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXJfaG9zdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc2NoZW1hdGljcy91dGlscy90eXBlc2NyaXB0L2NvbXBpbGVyX2hvc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsT0FBTyxFQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ2hELE9BQU8sS0FBSyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBSW5EOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FDbEMsSUFBVSxFQUFFLFlBQW9CLEVBQUUsUUFBZ0IsRUFBRSxZQUE2QixFQUNqRixlQUEwQjtJQUM1Qix3RkFBd0Y7SUFDeEYsMkZBQTJGO0lBQzNGLGdGQUFnRjtJQUNoRixZQUFZLEdBQUcsT0FBTyxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUMvQyxNQUFNLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDdEUsTUFBTSxJQUFJLEdBQUcsMkJBQTJCLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3ZGLE1BQU0sT0FBTyxHQUNULEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDM0YsT0FBTyxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFDLENBQUM7QUFDakMsQ0FBQztBQUVELE1BQU0sVUFBVSwyQkFBMkIsQ0FDdkMsSUFBVSxFQUFFLE9BQTJCLEVBQUUsUUFBZ0IsRUFDekQsUUFBeUI7SUFDM0IsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsRCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBRXRDLDZFQUE2RTtJQUM3RSwrRUFBK0U7SUFDL0UsdUVBQXVFO0lBQ3ZFLGdCQUFnQjtJQUNoQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxFQUFFOztRQUN6QixNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdEQsSUFBSSxNQUFNLEdBQXFCLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTVELElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUN4QiwrRUFBK0U7WUFDL0UsbUZBQW1GO1lBQ25GLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLE1BQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQywwQ0FBRSxRQUFRLEVBQUUsQ0FBQztTQUN0RjtRQUVELDJFQUEyRTtRQUMzRSx1Q0FBdUM7UUFDdkMscURBQXFEO1FBQ3JELE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzVELENBQUMsQ0FBQztJQUVGLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGNBQWMsQ0FDMUIsUUFBZ0IsRUFBRSxVQUF5QixFQUFFLE9BQW1CO0lBQ2xFLHNFQUFzRTtJQUN0RSxJQUFJLFVBQVUsQ0FBQyxpQkFBaUIsSUFBSSxPQUFPLENBQUMsK0JBQStCLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDdkYsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELGlHQUFpRztJQUNqRywyRkFBMkY7SUFDM0YsK0ZBQStGO0lBQy9GLHdGQUF3RjtJQUN4RixxSkFBcUo7SUFDckosT0FBTyxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge1RyZWV9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9zY2hlbWF0aWNzJztcbmltcG9ydCB7ZGlybmFtZSwgcmVsYXRpdmUsIHJlc29sdmV9IGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQge3BhcnNlVHNjb25maWdGaWxlfSBmcm9tICcuL3BhcnNlX3RzY29uZmlnJztcblxuZXhwb3J0IHR5cGUgRmFrZVJlYWRGaWxlRm4gPSAoZmlsZU5hbWU6IHN0cmluZykgPT4gc3RyaW5nfHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgVHlwZVNjcmlwdCBwcm9ncmFtIGluc3RhbmNlIGZvciBhIFR5cGVTY3JpcHQgcHJvamVjdCB3aXRoaW5cbiAqIHRoZSB2aXJ0dWFsIGZpbGUgc3lzdGVtIHRyZWUuXG4gKiBAcGFyYW0gdHJlZSBWaXJ0dWFsIGZpbGUgc3lzdGVtIHRyZWUgdGhhdCBjb250YWlucyB0aGUgc291cmNlIGZpbGVzLlxuICogQHBhcmFtIHRzY29uZmlnUGF0aCBWaXJ0dWFsIGZpbGUgc3lzdGVtIHBhdGggdGhhdCByZXNvbHZlcyB0byB0aGUgVHlwZVNjcmlwdCBwcm9qZWN0LlxuICogQHBhcmFtIGJhc2VQYXRoIEJhc2UgcGF0aCBmb3IgdGhlIHZpcnR1YWwgZmlsZSBzeXN0ZW0gdHJlZS5cbiAqIEBwYXJhbSBmYWtlRmlsZVJlYWQgT3B0aW9uYWwgZmlsZSByZWFkZXIgZnVuY3Rpb24uIENhbiBiZSB1c2VkIHRvIG92ZXJ3cml0ZSBmaWxlcyBpblxuICogICB0aGUgVHlwZVNjcmlwdCBwcm9ncmFtLCBvciB0byBhZGQgaW4tbWVtb3J5IGZpbGVzIChlLmcuIHRvIGFkZCBnbG9iYWwgdHlwZXMpLlxuICogQHBhcmFtIGFkZGl0aW9uYWxGaWxlcyBBZGRpdGlvbmFsIGZpbGUgcGF0aHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHByb2dyYW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNaWdyYXRpb25Qcm9ncmFtKFxuICAgIHRyZWU6IFRyZWUsIHRzY29uZmlnUGF0aDogc3RyaW5nLCBiYXNlUGF0aDogc3RyaW5nLCBmYWtlRmlsZVJlYWQ/OiBGYWtlUmVhZEZpbGVGbixcbiAgICBhZGRpdGlvbmFsRmlsZXM/OiBzdHJpbmdbXSkge1xuICAvLyBSZXNvbHZlIHRoZSB0c2NvbmZpZyBwYXRoIHRvIGFuIGFic29sdXRlIHBhdGguIFRoaXMgaXMgbmVlZGVkIGFzIFR5cGVTY3JpcHQgb3RoZXJ3aXNlXG4gIC8vIGlzIG5vdCBhYmxlIHRvIHJlc29sdmUgcm9vdCBkaXJlY3RvcmllcyBpbiB0aGUgZ2l2ZW4gdHNjb25maWcuIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmRcbiAgLy8gaW4gdGhlIGZvbGxvd2luZyBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNzczMS5cbiAgdHNjb25maWdQYXRoID0gcmVzb2x2ZShiYXNlUGF0aCwgdHNjb25maWdQYXRoKTtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VUc2NvbmZpZ0ZpbGUodHNjb25maWdQYXRoLCBkaXJuYW1lKHRzY29uZmlnUGF0aCkpO1xuICBjb25zdCBob3N0ID0gY3JlYXRlTWlncmF0aW9uQ29tcGlsZXJIb3N0KHRyZWUsIHBhcnNlZC5vcHRpb25zLCBiYXNlUGF0aCwgZmFrZUZpbGVSZWFkKTtcbiAgY29uc3QgcHJvZ3JhbSA9XG4gICAgICB0cy5jcmVhdGVQcm9ncmFtKHBhcnNlZC5maWxlTmFtZXMuY29uY2F0KGFkZGl0aW9uYWxGaWxlcyB8fCBbXSksIHBhcnNlZC5vcHRpb25zLCBob3N0KTtcbiAgcmV0dXJuIHtwYXJzZWQsIGhvc3QsIHByb2dyYW19O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWlncmF0aW9uQ29tcGlsZXJIb3N0KFxuICAgIHRyZWU6IFRyZWUsIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucywgYmFzZVBhdGg6IHN0cmluZyxcbiAgICBmYWtlUmVhZD86IEZha2VSZWFkRmlsZUZuKTogdHMuQ29tcGlsZXJIb3N0IHtcbiAgY29uc3QgaG9zdCA9IHRzLmNyZWF0ZUNvbXBpbGVySG9zdChvcHRpb25zLCB0cnVlKTtcbiAgY29uc3QgZGVmYXVsdFJlYWRGaWxlID0gaG9zdC5yZWFkRmlsZTtcblxuICAvLyBXZSBuZWVkIHRvIG92ZXJ3cml0ZSB0aGUgaG9zdCBcInJlYWRGaWxlXCIgbWV0aG9kLCBhcyB3ZSB3YW50IHRoZSBUeXBlU2NyaXB0XG4gIC8vIHByb2dyYW0gdG8gYmUgYmFzZWQgb24gdGhlIGZpbGUgY29udGVudHMgaW4gdGhlIHZpcnR1YWwgZmlsZSB0cmVlLiBPdGhlcndpc2VcbiAgLy8gaWYgd2UgcnVuIG11bHRpcGxlIG1pZ3JhdGlvbnMgd2UgbWlnaHQgaGF2ZSBpbnRlcnNlY3RpbmcgY2hhbmdlcyBhbmRcbiAgLy8gc291cmNlIGZpbGVzLlxuICBob3N0LnJlYWRGaWxlID0gZmlsZU5hbWUgPT4ge1xuICAgIGNvbnN0IHRyZWVSZWxhdGl2ZVBhdGggPSByZWxhdGl2ZShiYXNlUGF0aCwgZmlsZU5hbWUpO1xuICAgIGxldCByZXN1bHQ6IHN0cmluZ3x1bmRlZmluZWQgPSBmYWtlUmVhZD8uKHRyZWVSZWxhdGl2ZVBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRpdmUgcGF0aCByZXNvbHZlZCB0byBzb21ld2hlcmUgb3V0c2lkZSBvZiB0aGUgdHJlZSwgZmFsbCBiYWNrIHRvXG4gICAgICAvLyBUeXBlU2NyaXB0J3MgZGVmYXVsdCBmaWxlIHJlYWRpbmcgZnVuY3Rpb24gc2luY2UgdGhlIGB0cmVlYCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAgcmVzdWx0ID0gdHJlZVJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpID8gZGVmYXVsdFJlYWRGaWxlLmNhbGwoaG9zdCwgZmlsZU5hbWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUucmVhZCh0cmVlUmVsYXRpdmVQYXRoKT8udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBTdHJpcCBCT00gYXMgb3RoZXJ3aXNlIFRTQyBtZXRob2RzIChFeDogZ2V0V2lkdGgpIHdpbGwgcmV0dXJuIGFuIG9mZnNldCxcbiAgICAvLyB3aGljaCBicmVha3MgdGhlIENMSSBVcGRhdGVSZWNvcmRlci5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvcHVsbC8zMDcxOVxuICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQucmVwbGFjZSgvXlxcdUZFRkYvLCAnJykgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIGhvc3Q7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBmaWxlIGNhbiBiZSBtaWdyYXRlIGJ5IG91ciBhdXRvbWF0ZWQgbWlncmF0aW9ucy5cbiAqIEBwYXJhbSBiYXNlUGF0aCBBYnNvbHV0ZSBwYXRoIHRvIHRoZSBwcm9qZWN0LlxuICogQHBhcmFtIHNvdXJjZUZpbGUgRmlsZSBiZWluZyBjaGVja2VkLlxuICogQHBhcmFtIHByb2dyYW0gUHJvZ3JhbSB0aGF0IGluY2x1ZGVzIHRoZSBzb3VyY2UgZmlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbk1pZ3JhdGVGaWxlKFxuICAgIGJhc2VQYXRoOiBzdHJpbmcsIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIHByb2dyYW06IHRzLlByb2dyYW0pOiBib29sZWFuIHtcbiAgLy8gV2Ugc2hvdWxkbid0IG1pZ3JhdGUgLmQudHMgZmlsZXMgb3IgZmlsZXMgZnJvbSBhbiBleHRlcm5hbCBsaWJyYXJ5LlxuICBpZiAoc291cmNlRmlsZS5pc0RlY2xhcmF0aW9uRmlsZSB8fCBwcm9ncmFtLmlzU291cmNlRmlsZUZyb21FeHRlcm5hbExpYnJhcnkoc291cmNlRmlsZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPdXIgbWlncmF0aW9ucyBhcmUgc2V0IHVwIHRvIGNyZWF0ZSBhIGBQcm9ncmFtYCBmcm9tIHRoZSBwcm9qZWN0J3MgdHNjb25maWcgYW5kIHRvIG1pZ3JhdGUgYWxsXG4gIC8vIHRoZSBmaWxlcyB3aXRoaW4gdGhlIHByb2dyYW0uIFRoaXMgY2FuIGluY2x1ZGUgZmlsZXMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgQW5ndWxhciBDTElcbiAgLy8gcHJvamVjdC4gV2UgY2FuJ3QgbWlncmF0ZSBmaWxlcyBvdXRzaWRlIG9mIHRoZSBwcm9qZWN0LCBiZWNhdXNlIG91ciBmaWxlIHN5c3RlbSBpbnRlcmFjdGlvbnNcbiAgLy8gZ28gdGhyb3VnaCB0aGUgQ0xJJ3MgYFRyZWVgIHdoaWNoIGFzc3VtZXMgdGhhdCBhbGwgZmlsZXMgYXJlIHdpdGhpbiB0aGUgcHJvamVjdC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLWNsaS9ibG9iLzBiMDk2MWM5YzIzM2E4MjViNmU0YmI1OWFiN2YwNzkwZjliMTQ2NzYvcGFja2FnZXMvYW5ndWxhcl9kZXZraXQvc2NoZW1hdGljcy9zcmMvdHJlZS9ob3N0LXRyZWUudHMjTDEzMVxuICByZXR1cm4gIXJlbGF0aXZlKGJhc2VQYXRoLCBzb3VyY2VGaWxlLmZpbGVOYW1lKS5zdGFydHNXaXRoKCcuLicpO1xufVxuIl19