import { Injectable, Inject, Optional, NgZone, PLATFORM_ID, InjectionToken } from '@angular/core';
import { Observable, of, from, merge, Subject } from 'rxjs';
import { switchMap, map, observeOn, shareReplay, first, filter, switchMapTo, subscribeOn } from 'rxjs/operators';
import { FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵlazySDKProxy, ɵfirebaseAppFactory, ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵapplyMixins } from '@angular/fire';
import { isPlatformServer } from '@angular/common';
import { proxyPolyfillCompat } from './base';
import { ɵfetchInstance } from '@angular/fire';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
export const USE_EMULATOR = new InjectionToken('angularfire2.auth.use-emulator');
export const SETTINGS = new InjectionToken('angularfire2.auth.settings');
export const TENANT_ID = new InjectionToken('angularfire2.auth.tenant-id');
export const LANGUAGE_CODE = new InjectionToken('angularfire2.auth.langugage-code');
export const USE_DEVICE_LANGUAGE = new InjectionToken('angularfire2.auth.use-device-language');
export const PERSISTENCE = new InjectionToken('angularfire.auth.persistence');
export class AngularFireAuth {
    constructor(options, nameOrConfig, 
    // tslint:disable-next-line:ban-types
    platformId, zone, _useEmulator, // can't use the tuple here
    _settings, // can't use firebase.auth.AuthSettings here
    tenantId, languageCode, useDeviceLanguage, persistence) {
        const schedulers = new ɵAngularFireSchedulers(zone);
        const keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(schedulers);
        const logins = new Subject();
        const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/auth'))), map(() => ɵfirebaseAppFactory(options, zone, nameOrConfig)), map(app => zone.runOutsideAngular(() => {
            const useEmulator = _useEmulator;
            const settings = _settings;
            return ɵfetchInstance(`${app.name}.auth`, 'AngularFireAuth', app, () => {
                const auth = zone.runOutsideAngular(() => app.auth());
                if (useEmulator) {
                    // Firebase Auth doesn't conform to the useEmulator convention, let's smooth that over
                    auth.useEmulator(`http://${useEmulator.join(':')}`);
                }
                if (tenantId) {
                    auth.tenantId = tenantId;
                }
                auth.languageCode = languageCode;
                if (useDeviceLanguage) {
                    auth.useDeviceLanguage();
                }
                if (settings) {
                    for (const [k, v] of Object.entries(settings)) {
                        auth.settings[k] = v;
                    }
                }
                if (persistence) {
                    auth.setPersistence(persistence);
                }
                return auth;
            }, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);
        })), shareReplay({ bufferSize: 1, refCount: false }));
        if (isPlatformServer(platformId)) {
            this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);
        }
        else {
            // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth
            //       (e.g, `import { auth } from 'firebase/app'`) are getting an undefined auth object unexpectedly
            //       as we're completely lazy. Let's eagerly load the Auth SDK here.
            //       There could potentially be race conditions still... but this greatly decreases the odds while
            //       we reevaluate the API.
            const _ = auth.pipe(first()).subscribe();
            const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({ bufferSize: 1, refCount: false }));
            const fromCallback = (cb) => new Observable(subscriber => ({ unsubscribe: zone.runOutsideAngular(() => cb(subscriber)) }));
            const authStateChanged = auth.pipe(switchMap(auth => fromCallback(auth.onAuthStateChanged.bind(auth))));
            const idTokenChanged = auth.pipe(switchMap(auth => fromCallback(auth.onIdTokenChanged.bind(auth))));
            this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
            this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
            this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));
            this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));
            this.credential = merge(redirectResult, logins, 
            // pipe in null authState to make credential zipable, just a weird devexp if
            // authState and user go null to still have a credential
            this.authState.pipe(filter(it => !it))).pipe(
            // handle the { user: { } } when a user is already logged in, rather have null
            // TODO handle the type corcersion better
            map(credential => (credential === null || credential === void 0 ? void 0 : credential.user) ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
        }
        return ɵlazySDKProxy(this, auth, zone, { spy: {
                apply: (name, _, val) => {
                    // If they call a signIn or createUser function listen into the promise
                    // this will give us the user credential, push onto the logins Subject
                    // to be consumed in .credential
                    if (name.startsWith('signIn') || name.startsWith('createUser')) {
                        // TODO fix the types, the trouble is UserCredential has everything optional
                        val.then((user) => logins.next(user));
                    }
                }
            } });
    }
}
/** @nocollapse */ AngularFireAuth.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFireAuth_Factory() { return new AngularFireAuth(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8)); }, token: AngularFireAuth, providedIn: "any" });
AngularFireAuth.decorators = [
    { type: Injectable, args: [{
                providedIn: 'any'
            },] }
];
/** @nocollapse */
AngularFireAuth.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [USE_EMULATOR,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [TENANT_ID,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [LANGUAGE_CODE,] }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [USE_DEVICE_LANGUAGE,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [PERSISTENCE,] }] }
];
ɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hdXRoL2F1dGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDakgsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixpQkFBaUIsRUFJakIsYUFBYSxFQUNiLG1CQUFtQixFQUNuQixzQkFBc0IsRUFDdEIsOEJBQThCLEVBQzlCLFlBQVksRUFDYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDN0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0FBSy9DLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBdUIsZ0NBQWdDLENBQUMsQ0FBQztBQUV2RyxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxjQUFjLENBQTZCLDRCQUE0QixDQUFDLENBQUM7QUFDckcsTUFBTSxDQUFDLE1BQU0sU0FBUyxHQUFHLElBQUksY0FBYyxDQUFTLDZCQUE2QixDQUFDLENBQUM7QUFDbkYsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLElBQUksY0FBYyxDQUFTLGtDQUFrQyxDQUFDLENBQUM7QUFD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WUFBSSxNQUFNLFNBQUMsUUFBUTt5Q0FDM0IsUUFBUSxZQUFJLE1BQU0sU0FBQyxTQUFTO3lDQUM1QixRQUFRLFlBQUksTUFBTSxTQUFDLGFBQWE7MENBQ2hDLFFBQVEsWUFBSSxNQUFNLFNBQUMsbUJBQW1CO3lDQUN0QyxRQUFRLFlBQUksTUFBTSxTQUFDLFdBQVc7O0FBMkhuQyxZQUFZLENBQUMsZUFBZSxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0LCBPcHRpb25hbCwgTmdab25lLCBQTEFURk9STV9JRCwgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBmcm9tLCBtZXJnZSwgU3ViamVjdCwgU3Vic2NyaWJlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCBtYXAsIG9ic2VydmVPbiwgc2hhcmVSZXBsYXksIGZpcnN0LCBmaWx0ZXIsIHN3aXRjaE1hcFRvLCBzdWJzY3JpYmVPbiB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gIEZJUkVCQVNFX09QVElPTlMsXG4gIEZJUkVCQVNFX0FQUF9OQU1FLFxuICBGaXJlYmFzZU9wdGlvbnMsXG4gIEZpcmViYXNlQXBwQ29uZmlnLFxuICDJtVByb21pc2VQcm94eSxcbiAgybVsYXp5U0RLUHJveHksXG4gIMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyxcbiAgybVrZWVwVW5zdGFibGVVbnRpbEZpcnN0RmFjdG9yeSxcbiAgybVhcHBseU1peGluc1xufSBmcm9tICdAYW5ndWxhci9maXJlJztcbmltcG9ydCBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybVNlcnZlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBwcm94eVBvbHlmaWxsQ29tcGF0IH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IMm1ZmV0Y2hJbnN0YW5jZSB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFuZ3VsYXJGaXJlQXV0aCBleHRlbmRzIMm1UHJvbWlzZVByb3h5PGZpcmViYXNlLmF1dGguQXV0aD4ge31cblxudHlwZSBVc2VFbXVsYXRvckFyZ3VtZW50cyA9IFtzdHJpbmcsIG51bWJlcl07XG5leHBvcnQgY29uc3QgVVNFX0VNVUxBVE9SID0gbmV3IEluamVjdGlvblRva2VuPFVzZUVtdWxhdG9yQXJndW1lbnRzPignYW5ndWxhcmZpcmUyLmF1dGgudXNlLWVtdWxhdG9yJyk7XG5cbmV4cG9ydCBjb25zdCBTRVRUSU5HUyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxmaXJlYmFzZS5hdXRoLkF1dGhTZXR0aW5ncz4oJ2FuZ3VsYXJmaXJlMi5hdXRoLnNldHRpbmdzJyk7XG5leHBvcnQgY29uc3QgVEVOQU5UX0lEID0gbmV3IEluamVjdGlvblRva2VuPHN0cmluZz4oJ2FuZ3VsYXJmaXJlMi5hdXRoLnRlbmFudC1pZCcpO1xuZXhwb3J0IGNvbnN0IExBTkdVQUdFX0NPREUgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignYW5ndWxhcmZpcmUyLmF1dGgubGFuZ3VnYWdlLWNvZGUnKTtcbmV4cG9ydCBjb25zdCBVU0VfREVWSUNFX0xBTkdVQUdFID0gbmV3IEluamVjdGlvblRva2VuPGJvb2xlYW4+KCdhbmd1bGFyZmlyZTIuYXV0aC51c2UtZGV2aWNlLWxhbmd1YWdlJyk7XG5leHBvcnQgY29uc3QgUEVSU0lTVEVOQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignYW5ndWxhcmZpcmUuYXV0aC5wZXJzaXN0ZW5jZScpO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdhbnknXG59KVxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJGaXJlQXV0aCB7XG5cbiAgLyoqXG4gICAqIE9ic2VydmFibGUgb2YgYXV0aGVudGljYXRpb24gc3RhdGU7IGFzIG9mIEZpcmViYXNlIDQuMCB0aGlzIGlzIG9ubHkgdHJpZ2dlcmVkIHZpYSBzaWduLWluL291dFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGF1dGhTdGF0ZTogT2JzZXJ2YWJsZTxmaXJlYmFzZS5Vc2VyfG51bGw+O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlIG9mIHRoZSBjdXJyZW50bHkgc2lnbmVkLWluIHVzZXIncyBKV1QgdG9rZW4gdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciB0byBhIEZpcmViYXNlIHNlcnZpY2UgKG9yIG51bGwpLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGlkVG9rZW46IE9ic2VydmFibGU8c3RyaW5nfG51bGw+O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlIG9mIHRoZSBjdXJyZW50bHkgc2lnbmVkLWluIHVzZXIgKG9yIG51bGwpLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHVzZXI6IE9ic2VydmFibGU8ZmlyZWJhc2UuVXNlcnxudWxsPjtcblxuICAvKipcbiAgICogT2JzZXJ2YWJsZSBvZiB0aGUgY3VycmVudGx5IHNpZ25lZC1pbiB1c2VyJ3MgSWRUb2tlblJlc3VsdCBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIElEIHRva2VuIEpXVCBzdHJpbmcgYW5kIG90aGVyXG4gICAqIGhlbHBlciBwcm9wZXJ0aWVzIGZvciBnZXR0aW5nIGRpZmZlcmVudCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9rZW4gYXMgd2VsbCBhcyBhbGwgdGhlIGRlY29kZWQgcGF5bG9hZCBjbGFpbXNcbiAgICogKG9yIG51bGwpLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGlkVG9rZW5SZXN1bHQ6IE9ic2VydmFibGU8ZmlyZWJhc2UuYXV0aC5JZFRva2VuUmVzdWx0fG51bGw+O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlIG9mIHRoZSBjdXJyZW50bHkgc2lnbmVkLWluIHVzZXIncyBjcmVkZW50aWFsLCBvciBudWxsXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY3JlZGVudGlhbDogT2JzZXJ2YWJsZTxSZXF1aXJlZDxmaXJlYmFzZS5hdXRoLlVzZXJDcmVkZW50aWFsPnxudWxsPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEZJUkVCQVNFX09QVElPTlMpIG9wdGlvbnM6IEZpcmViYXNlT3B0aW9ucyxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KEZJUkVCQVNFX0FQUF9OQU1FKSBuYW1lT3JDb25maWc6IHN0cmluZ3xGaXJlYmFzZUFwcENvbmZpZ3xudWxsfHVuZGVmaW5lZCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuLXR5cGVzXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHpvbmU6IE5nWm9uZSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFVTRV9FTVVMQVRPUikgX3VzZUVtdWxhdG9yOiBhbnksIC8vIGNhbid0IHVzZSB0aGUgdHVwbGUgaGVyZVxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoU0VUVElOR1MpIF9zZXR0aW5nczogYW55LCAvLyBjYW4ndCB1c2UgZmlyZWJhc2UuYXV0aC5BdXRoU2V0dGluZ3MgaGVyZVxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoVEVOQU5UX0lEKSB0ZW5hbnRJZDogc3RyaW5nIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KExBTkdVQUdFX0NPREUpIGxhbmd1YWdlQ29kZTogc3RyaW5nIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFVTRV9ERVZJQ0VfTEFOR1VBR0UpIHVzZURldmljZUxhbmd1YWdlOiBib29sZWFuIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFBFUlNJU1RFTkNFKSBwZXJzaXN0ZW5jZTogc3RyaW5nIHwgbnVsbCxcbiAgKSB7XG4gICAgY29uc3Qgc2NoZWR1bGVycyA9IG5ldyDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyh6b25lKTtcbiAgICBjb25zdCBrZWVwVW5zdGFibGVVbnRpbEZpcnN0ID0gybVrZWVwVW5zdGFibGVVbnRpbEZpcnN0RmFjdG9yeShzY2hlZHVsZXJzKTtcbiAgICBjb25zdCBsb2dpbnMgPSBuZXcgU3ViamVjdDxSZXF1aXJlZDxmaXJlYmFzZS5hdXRoLlVzZXJDcmVkZW50aWFsPj4oKTtcblxuICAgIGNvbnN0IGF1dGggPSBvZih1bmRlZmluZWQpLnBpcGUoXG4gICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhciksXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBpbXBvcnQoJ2ZpcmViYXNlL2F1dGgnKSkpLFxuICAgICAgbWFwKCgpID0+IMm1ZmlyZWJhc2VBcHBGYWN0b3J5KG9wdGlvbnMsIHpvbmUsIG5hbWVPckNvbmZpZykpLFxuICAgICAgbWFwKGFwcCA9PiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgY29uc3QgdXNlRW11bGF0b3I6IFVzZUVtdWxhdG9yQXJndW1lbnRzIHwgbnVsbCA9IF91c2VFbXVsYXRvcjtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3M6IGZpcmViYXNlLmF1dGguQXV0aFNldHRpbmdzIHwgbnVsbCA9IF9zZXR0aW5ncztcbiAgICAgICAgcmV0dXJuIMm1ZmV0Y2hJbnN0YW5jZShgJHthcHAubmFtZX0uYXV0aGAsICdBbmd1bGFyRmlyZUF1dGgnLCBhcHAsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBhdXRoID0gem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBhcHAuYXV0aCgpKTtcbiAgICAgICAgICBpZiAodXNlRW11bGF0b3IpIHtcbiAgICAgICAgICAgIC8vIEZpcmViYXNlIEF1dGggZG9lc24ndCBjb25mb3JtIHRvIHRoZSB1c2VFbXVsYXRvciBjb252ZW50aW9uLCBsZXQncyBzbW9vdGggdGhhdCBvdmVyXG4gICAgICAgICAgICBhdXRoLnVzZUVtdWxhdG9yKGBodHRwOi8vJHt1c2VFbXVsYXRvci5qb2luKCc6Jyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZW5hbnRJZCkge1xuICAgICAgICAgICAgYXV0aC50ZW5hbnRJZCA9IHRlbmFudElkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdXRoLmxhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgICAgICAgICBpZiAodXNlRGV2aWNlTGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGF1dGgudXNlRGV2aWNlTGFuZ3VhZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgYXV0aC5zZXR0aW5nc1trXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgYXV0aC5zZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhdXRoO1xuICAgICAgICB9LCBbdXNlRW11bGF0b3IsIHRlbmFudElkLCBsYW5ndWFnZUNvZGUsIHVzZURldmljZUxhbmd1YWdlLCBzZXR0aW5ncywgcGVyc2lzdGVuY2VdKTtcbiAgICAgIH0pKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IGZhbHNlIH0pLFxuICAgICk7XG5cbiAgICBpZiAoaXNQbGF0Zm9ybVNlcnZlcihwbGF0Zm9ybUlkKSkge1xuXG4gICAgICB0aGlzLmF1dGhTdGF0ZSA9IHRoaXMudXNlciA9IHRoaXMuaWRUb2tlbiA9IHRoaXMuaWRUb2tlblJlc3VsdCA9IHRoaXMuY3JlZGVudGlhbCA9IG9mKG51bGwpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gSEFDSywgYXMgd2UncmUgZXhwb3J0aW5nIGF1dGguQXV0aCwgcmF0aGVyIHRoYW4gYXV0aCwgZGV2ZWxvcGVycyBpbXBvcnRpbmcgZmlyZWJhc2UuYXV0aFxuICAgICAgLy8gICAgICAgKGUuZywgYGltcG9ydCB7IGF1dGggfSBmcm9tICdmaXJlYmFzZS9hcHAnYCkgYXJlIGdldHRpbmcgYW4gdW5kZWZpbmVkIGF1dGggb2JqZWN0IHVuZXhwZWN0ZWRseVxuICAgICAgLy8gICAgICAgYXMgd2UncmUgY29tcGxldGVseSBsYXp5LiBMZXQncyBlYWdlcmx5IGxvYWQgdGhlIEF1dGggU0RLIGhlcmUuXG4gICAgICAvLyAgICAgICBUaGVyZSBjb3VsZCBwb3RlbnRpYWxseSBiZSByYWNlIGNvbmRpdGlvbnMgc3RpbGwuLi4gYnV0IHRoaXMgZ3JlYXRseSBkZWNyZWFzZXMgdGhlIG9kZHMgd2hpbGVcbiAgICAgIC8vICAgICAgIHdlIHJlZXZhbHVhdGUgdGhlIEFQSS5cbiAgICAgIGNvbnN0IF8gPSBhdXRoLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGNvbnN0IHJlZGlyZWN0UmVzdWx0ID0gYXV0aC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoYXV0aCA9PiBhdXRoLmdldFJlZGlyZWN0UmVzdWx0KCkudGhlbihpdCA9PiBpdCwgKCkgPT4gbnVsbCkpLFxuICAgICAgICBrZWVwVW5zdGFibGVVbnRpbEZpcnN0LFxuICAgICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiBmYWxzZSB9KSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGZyb21DYWxsYmFjayA9IDxUID0gYW55PihjYjogKHN1YjogU3Vic2NyaWJlcjxUPikgPT4gKCkgPT4gdm9pZCkgPT4gbmV3IE9ic2VydmFibGU8VD4oc3Vic2NyaWJlciA9PlxuICAgICAgICAoeyB1bnN1YnNjcmliZTogem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBjYihzdWJzY3JpYmVyKSkgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGF1dGhTdGF0ZUNoYW5nZWQgPSBhdXRoLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcChhdXRoID0+IGZyb21DYWxsYmFjayhhdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZC5iaW5kKGF1dGgpKSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBpZFRva2VuQ2hhbmdlZCA9IGF1dGgucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKGF1dGggPT4gZnJvbUNhbGxiYWNrKGF1dGgub25JZFRva2VuQ2hhbmdlZC5iaW5kKGF1dGgpKSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuYXV0aFN0YXRlID0gcmVkaXJlY3RSZXN1bHQucGlwZShcbiAgICAgICAgc3dpdGNoTWFwVG8oYXV0aFN0YXRlQ2hhbmdlZCksXG4gICAgICAgIHN1YnNjcmliZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5pbnNpZGVBbmd1bGFyKSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMudXNlciA9IHJlZGlyZWN0UmVzdWx0LnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcFRvKGlkVG9rZW5DaGFuZ2VkKSxcbiAgICAgICAgc3Vic2NyaWJlT24oc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhciksXG4gICAgICAgIG9ic2VydmVPbihzY2hlZHVsZXJzLmluc2lkZUFuZ3VsYXIpLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5pZFRva2VuID0gdGhpcy51c2VyLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCh1c2VyID0+IHVzZXIgPyBmcm9tKHVzZXIuZ2V0SWRUb2tlbigpKSA6IG9mKG51bGwpKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5pZFRva2VuUmVzdWx0ID0gdGhpcy51c2VyLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCh1c2VyID0+IHVzZXIgPyBmcm9tKHVzZXIuZ2V0SWRUb2tlblJlc3VsdCgpKSA6IG9mKG51bGwpKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5jcmVkZW50aWFsID0gbWVyZ2UoXG4gICAgICAgIHJlZGlyZWN0UmVzdWx0LFxuICAgICAgICBsb2dpbnMsXG4gICAgICAgIC8vIHBpcGUgaW4gbnVsbCBhdXRoU3RhdGUgdG8gbWFrZSBjcmVkZW50aWFsIHppcGFibGUsIGp1c3QgYSB3ZWlyZCBkZXZleHAgaWZcbiAgICAgICAgLy8gYXV0aFN0YXRlIGFuZCB1c2VyIGdvIG51bGwgdG8gc3RpbGwgaGF2ZSBhIGNyZWRlbnRpYWxcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUucGlwZShmaWx0ZXIoaXQgPT4gIWl0KSlcbiAgICAgICkucGlwZShcbiAgICAgICAgLy8gaGFuZGxlIHRoZSB7IHVzZXI6IHsgfSB9IHdoZW4gYSB1c2VyIGlzIGFscmVhZHkgbG9nZ2VkIGluLCByYXRoZXIgaGF2ZSBudWxsXG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIHRoZSB0eXBlIGNvcmNlcnNpb24gYmV0dGVyXG4gICAgICAgIG1hcChjcmVkZW50aWFsID0+IGNyZWRlbnRpYWw/LnVzZXIgPyBjcmVkZW50aWFsIGFzIFJlcXVpcmVkPGZpcmViYXNlLmF1dGguVXNlckNyZWRlbnRpYWw+IDogbnVsbCksXG4gICAgICAgIHN1YnNjcmliZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5pbnNpZGVBbmd1bGFyKSxcbiAgICAgICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gybVsYXp5U0RLUHJveHkodGhpcywgYXV0aCwgem9uZSwgeyBzcHk6IHtcbiAgICAgIGFwcGx5OiAobmFtZSwgXywgdmFsKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZXkgY2FsbCBhIHNpZ25JbiBvciBjcmVhdGVVc2VyIGZ1bmN0aW9uIGxpc3RlbiBpbnRvIHRoZSBwcm9taXNlXG4gICAgICAgIC8vIHRoaXMgd2lsbCBnaXZlIHVzIHRoZSB1c2VyIGNyZWRlbnRpYWwsIHB1c2ggb250byB0aGUgbG9naW5zIFN1YmplY3RcbiAgICAgICAgLy8gdG8gYmUgY29uc3VtZWQgaW4gLmNyZWRlbnRpYWxcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnc2lnbkluJykgfHwgbmFtZS5zdGFydHNXaXRoKCdjcmVhdGVVc2VyJykpIHtcbiAgICAgICAgICAvLyBUT0RPIGZpeCB0aGUgdHlwZXMsIHRoZSB0cm91YmxlIGlzIFVzZXJDcmVkZW50aWFsIGhhcyBldmVyeXRoaW5nIG9wdGlvbmFsXG4gICAgICAgICAgdmFsLnRoZW4oKHVzZXI6IGZpcmViYXNlLmF1dGguVXNlckNyZWRlbnRpYWwpID0+IGxvZ2lucy5uZXh0KHVzZXIgYXMgYW55KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9fSk7XG5cbiAgfVxuXG59XG5cbsm1YXBwbHlNaXhpbnMoQW5ndWxhckZpcmVBdXRoLCBbcHJveHlQb2x5ZmlsbENvbXBhdF0pO1xuIl19