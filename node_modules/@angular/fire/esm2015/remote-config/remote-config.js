import { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID } from '@angular/core';
import { concat, EMPTY, Observable, of, pipe } from 'rxjs';
import { debounceTime, distinctUntilChanged, filter, groupBy, map, mergeMap, observeOn, scan, shareReplay, startWith, switchMap, tap, withLatestFrom } from 'rxjs/operators';
import { FIREBASE_APP_NAME, FIREBASE_OPTIONS, ɵAngularFireSchedulers, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, ɵapplyMixins } from '@angular/fire';
import { isPlatformBrowser } from '@angular/common';
import firebase from 'firebase/app';
import { proxyPolyfillCompat } from './base';
import { ɵfetchInstance } from '@angular/fire';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
export const SETTINGS = new InjectionToken('angularfire2.remoteConfig.settings');
export const DEFAULTS = new InjectionToken('angularfire2.remoteConfig.defaultConfig');
const AS_TO_FN = { strings: 'asString', numbers: 'asNumber', booleans: 'asBoolean' };
const STATIC_VALUES = { numbers: 0, booleans: false, strings: undefined };
// TODO look into the types here, I don't like the anys
const proxyAll = (observable, as) => new Proxy(observable.pipe(mapToObject(as)), {
    get: (self, name) => self[name] || observable.pipe(map(all => all.find(p => p.key === name)), map(param => param ? param[AS_TO_FN[as]]() : STATIC_VALUES[as]), distinctUntilChanged())
});
const ɵ0 = proxyAll;
// TODO export as implements Partial<...> so minor doesn't break us
export class Value {
    // tslint:disable-next-line:variable-name
    constructor(_source, _value) {
        this._source = _source;
        this._value = _value;
    }
    asBoolean() {
        return ['1', 'true', 't', 'y', 'yes', 'on'].indexOf(this._value.toLowerCase()) > -1;
    }
    asString() {
        return this._value;
    }
    asNumber() {
        return Number(this._value) || 0;
    }
    getSource() {
        return this._source;
    }
}
// SEMVER use ConstructorParameters when we can support Typescript 3.6
export class Parameter extends Value {
    constructor(key, fetchTimeMillis, source, value) {
        super(source, value);
        this.key = key;
        this.fetchTimeMillis = fetchTimeMillis;
    }
}
// If it's a Parameter array, test any, else test the individual Parameter
const filterTest = (fn) => filter(it => Array.isArray(it) ? it.some(fn) : fn(it));
const ɵ1 = filterTest;
// Allow the user to bypass the default values and wait till they get something from the server, even if it's a cached copy;
// if used in conjuntion with first() it will only fetch RC values from the server if they aren't cached locally
export const filterRemote = () => filterTest(p => p.getSource() === 'remote');
// filterFresh allows the developer to effectively set up a maximum cache time
export const filterFresh = (howRecentInMillis) => filterTest(p => p.fetchTimeMillis + howRecentInMillis >= new Date().getTime());
// I ditched loading the defaults into RC and a simple map for scan since we already have our own defaults implementation.
// The idea here being that if they have a default that never loads from the server, they will be able to tell via fetchTimeMillis
// on the Parameter. Also if it doesn't come from the server it won't emit again in .changes, due to the distinctUntilChanged,
// which we can simplify to === rather than deep comparison
const scanToParametersArray = (remoteConfig) => pipe(withLatestFrom(remoteConfig), scan((existing, [all, rc]) => {
    // SEMVER use "new Set" to unique once we're only targeting es6
    // at the scale we expect remote config to be at, we probably won't see a performance hit from this unoptimized uniqueness
    // implementation.
    // const allKeys = [...new Set([...existing.map(p => p.key), ...Object.keys(all)])];
    const allKeys = [...existing.map(p => p.key), ...Object.keys(all)].filter((v, i, a) => a.indexOf(v) === i);
    return allKeys.map(key => {
        const updatedValue = all[key];
        return updatedValue ? new Parameter(key, rc ? rc.fetchTimeMillis : -1, updatedValue.getSource(), updatedValue.asString())
            : existing.find(p => p.key === key);
    });
}, []));
const ɵ2 = scanToParametersArray;
export class AngularFireRemoteConfig {
    constructor(options, nameOrConfig, settings, defaultConfig, zone, 
    // tslint:disable-next-line:ban-types
    platformId) {
        this.zone = zone;
        const schedulers = new ɵAngularFireSchedulers(zone);
        const remoteConfig$ = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => isPlatformBrowser(platformId) ? import('firebase/remote-config') : EMPTY), switchMap(() => import('@firebase/remote-config')), tap(rc => rc.registerRemoteConfig && rc.registerRemoteConfig(firebase)), map(() => ɵfirebaseAppFactory(options, zone, nameOrConfig)), map(app => ɵfetchInstance(`${app.name}.remote-config`, 'AngularFireRemoteConfig', app, () => {
            const rc = app.remoteConfig();
            if (settings) {
                rc.settings = settings;
            }
            if (defaultConfig) {
                rc.defaultConfig = defaultConfig;
            }
            return rc;
        }, [settings, defaultConfig])), 
        // tslint:disable-next-line
        startWith(undefined), shareReplay({ bufferSize: 1, refCount: false }));
        const loadedRemoteConfig$ = remoteConfig$.pipe(filter(rc => !!rc));
        const default$ = of(Object.keys(defaultConfig || {}).reduce((c, k) => (Object.assign(Object.assign({}, c), { [k]: new Value('default', defaultConfig[k].toString()) })), {}));
        // we should filter out the defaults we provided to RC, since we have our own implementation
        // that gives us a -1 for fetchTimeMillis (so filterFresh can filter them out)
        const filterOutDefaults = map(all => Object.keys(all)
            .filter(key => all[key].getSource() !== 'default')
            .reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: all[key] })), {}));
        const existing$ = loadedRemoteConfig$.pipe(switchMap(rc => rc.activate()
            .then(() => rc.ensureInitialized())
            .then(() => rc.getAll())), filterOutDefaults);
        const fresh$ = loadedRemoteConfig$.pipe(switchMap(rc => zone.runOutsideAngular(() => rc.fetchAndActivate()
            .then(() => rc.ensureInitialized())
            .then(() => rc.getAll()))), filterOutDefaults);
        this.parameters = concat(default$, existing$, fresh$).pipe(scanToParametersArray(remoteConfig$), ɵkeepUnstableUntilFirstFactory(schedulers), shareReplay({ bufferSize: 1, refCount: true }));
        this.changes = this.parameters.pipe(switchMap(params => of(...params)), groupBy(param => param.key), mergeMap(group => group.pipe(distinctUntilChanged())));
        this.strings = proxyAll(this.parameters, 'strings');
        this.booleans = proxyAll(this.parameters, 'booleans');
        this.numbers = proxyAll(this.parameters, 'numbers');
        return ɵlazySDKProxy(this, loadedRemoteConfig$, zone);
    }
}
/** @nocollapse */ AngularFireRemoteConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFireRemoteConfig_Factory() { return new AngularFireRemoteConfig(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(DEFAULTS, 8), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.PLATFORM_ID)); }, token: AngularFireRemoteConfig, providedIn: "any" });
AngularFireRemoteConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'any'
            },] }
];
/** @nocollapse */
AngularFireRemoteConfig.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEFAULTS,] }] },
    { type: NgZone },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
export const budget = (interval) => (source) => new Observable(observer => {
    let timedOut = false;
    // TODO use scheduler task rather than settimeout
    const timeout = setTimeout(() => {
        observer.complete();
        timedOut = true;
    }, interval);
    return source.subscribe({
        next(val) {
            if (!timedOut) {
                observer.next(val);
            }
        },
        error(err) {
            if (!timedOut) {
                clearTimeout(timeout);
                observer.error(err);
            }
        },
        complete() {
            if (!timedOut) {
                clearTimeout(timeout);
                observer.complete();
            }
        }
    });
});
const typedMethod = (it) => {
    switch (typeof it) {
        case 'string':
            return 'asString';
        case 'boolean':
            return 'asBoolean';
        case 'number':
            return 'asNumber';
        default:
            return 'asString';
    }
};
const ɵ3 = typedMethod;
export function scanToObject(to = 'strings') {
    return pipe(
    // TODO cleanup
    scan((c, p) => (Object.assign(Object.assign({}, c), { [p.key]: typeof to === 'object' ?
            p[typedMethod(to[p.key])]() :
            p[AS_TO_FN[to]]() })), typeof to === 'object' ?
        to :
        {}), debounceTime(1), budget(10), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));
}
export function mapToObject(to = 'strings') {
    return pipe(
    // TODO this is getting a little long, cleanup
    map((params) => params.reduce((c, p) => (Object.assign(Object.assign({}, c), { [p.key]: typeof to === 'object' ?
            p[typedMethod(to[p.key])]() :
            p[AS_TO_FN[to]]() })), typeof to === 'object' ?
        to :
        {})), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));
}
ɵapplyMixins(AngularFireRemoteConfig, [proxyPolyfillCompat]);
export { ɵ0, ɵ1, ɵ2, ɵ3 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVtb3RlLWNvbmZpZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9yZW1vdGUtY29uZmlnL3JlbW90ZS1jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUE0QixVQUFVLEVBQUUsRUFBRSxFQUFvQixJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkcsT0FBTyxFQUNMLFlBQVksRUFDWixvQkFBb0IsRUFDcEIsTUFBTSxFQUNOLE9BQU8sRUFDUCxHQUFHLEVBQ0gsUUFBUSxFQUNSLFNBQVMsRUFDVCxJQUFJLEVBQ0osV0FBVyxFQUNYLFNBQVMsRUFDVCxTQUFTLEVBQ1QsR0FBRyxFQUNILGNBQWMsRUFDZixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsZ0JBQWdCLEVBR2hCLHNCQUFzQixFQUN0QixtQkFBbUIsRUFDbkIsOEJBQThCLEVBQzlCLGFBQWEsRUFFYixZQUFZLEVBQ2IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxRQUFRLE1BQU0sY0FBYyxDQUFDO0FBRXBDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM3QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7QUFNL0MsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFHLElBQUksY0FBYyxDQUFXLG9DQUFvQyxDQUFDLENBQUM7QUFDM0YsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFHLElBQUksY0FBYyxDQUFpQix5Q0FBeUMsQ0FBQyxDQUFDO0FBS3RHLE1BQU0sUUFBUSxH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U0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDeEUsQ0FBQztBQUNKLENBQUM7QUFFRCxZQUFZLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBOZ1pvbmUsIE9wdGlvbmFsLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29uY2F0LCBFTVBUWSwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLCBPYnNlcnZhYmxlLCBvZiwgT3BlcmF0b3JGdW5jdGlvbiwgcGlwZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgZGVib3VuY2VUaW1lLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgZmlsdGVyLFxuICBncm91cEJ5LFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBvYnNlcnZlT24sXG4gIHNjYW4sXG4gIHNoYXJlUmVwbGF5LFxuICBzdGFydFdpdGgsXG4gIHN3aXRjaE1hcCxcbiAgdGFwLFxuICB3aXRoTGF0ZXN0RnJvbVxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBGSVJFQkFTRV9BUFBfTkFNRSxcbiAgRklSRUJBU0VfT1BUSU9OUyxcbiAgRmlyZWJhc2VBcHBDb25maWcsXG4gIEZpcmViYXNlT3B0aW9ucyxcbiAgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMsXG4gIMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5LFxuICDJtWxhenlTREtQcm94eSxcbiAgybVQcm9taXNlUHJveHksXG4gIMm1YXBwbHlNaXhpbnNcbn0gZnJvbSAnQGFuZ3VsYXIvZmlyZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHByb3h5UG9seWZpbGxDb21wYXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgybVmZXRjaEluc3RhbmNlIH0gZnJvbSAnQGFuZ3VsYXIvZmlyZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnVGVtcGxhdGUge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW48U2V0dGluZ3M+KCdhbmd1bGFyZmlyZTIucmVtb3RlQ29uZmlnLnNldHRpbmdzJyk7XG5leHBvcnQgY29uc3QgREVGQVVMVFMgPSBuZXcgSW5qZWN0aW9uVG9rZW48Q29uZmlnVGVtcGxhdGU+KCdhbmd1bGFyZmlyZTIucmVtb3RlQ29uZmlnLmRlZmF1bHRDb25maWcnKTtcblxuZXhwb3J0IGludGVyZmFjZSBBbmd1bGFyRmlyZVJlbW90ZUNvbmZpZyBleHRlbmRzIMm1UHJvbWlzZVByb3h5PGZpcmViYXNlLnJlbW90ZUNvbmZpZy5SZW1vdGVDb25maWc+IHtcbn1cblxuY29uc3QgQVNfVE9fRk4gPSB7IHN0cmluZ3M6ICdhc1N0cmluZycsIG51bWJlcnM6ICdhc051bWJlcicsIGJvb2xlYW5zOiAnYXNCb29sZWFuJyB9O1xuY29uc3QgU1RBVElDX1ZBTFVFUyA9IHsgbnVtYmVyczogMCwgYm9vbGVhbnM6IGZhbHNlLCBzdHJpbmdzOiB1bmRlZmluZWQgfTtcblxuLy8gVE9ETyBsb29rIGludG8gdGhlIHR5cGVzIGhlcmUsIEkgZG9uJ3QgbGlrZSB0aGUgYW55c1xuY29uc3QgcHJveHlBbGwgPSAob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxQYXJhbWV0ZXJbXT4sIGFzOiAnbnVtYmVycycgfCAnYm9vbGVhbnMnIHwgJ3N0cmluZ3MnKSA9PiBuZXcgUHJveHkoXG4gIG9ic2VydmFibGUucGlwZShtYXBUb09iamVjdChhcyBhcyBhbnkpKSwge1xuICAgIGdldDogKHNlbGYsIG5hbWU6IHN0cmluZykgPT4gc2VsZltuYW1lXSB8fCBvYnNlcnZhYmxlLnBpcGUoXG4gICAgICBtYXAoYWxsID0+IGFsbC5maW5kKHAgPT4gcC5rZXkgPT09IG5hbWUpKSxcbiAgICAgIG1hcChwYXJhbSA9PiBwYXJhbSA/IHBhcmFtW0FTX1RPX0ZOW2FzXV0oKSA6IFNUQVRJQ19WQUxVRVNbYXNdKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApXG4gIH1cbikgYXMgYW55O1xuXG4vLyBUT0RPIGV4cG9ydCBhcyBpbXBsZW1lbnRzIFBhcnRpYWw8Li4uPiBzbyBtaW5vciBkb2Vzbid0IGJyZWFrIHVzXG5leHBvcnQgY2xhc3MgVmFsdWUgaW1wbGVtZW50cyBmaXJlYmFzZS5yZW1vdGVDb25maWcuVmFsdWUge1xuICBhc0Jvb2xlYW4oKSB7XG4gICAgcmV0dXJuIFsnMScsICd0cnVlJywgJ3QnLCAneScsICd5ZXMnLCAnb24nXS5pbmRleE9mKHRoaXMuX3ZhbHVlLnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gIH1cblxuICBhc1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBhc051bWJlcigpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuX3ZhbHVlKSB8fCAwO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuICBjb25zdHJ1Y3RvcihwdWJsaWMgX3NvdXJjZTogZmlyZWJhc2UucmVtb3RlQ29uZmlnLlZhbHVlU291cmNlLCBwdWJsaWMgX3ZhbHVlOiBzdHJpbmcpIHtcbiAgfVxufVxuXG4vLyBTRU1WRVIgdXNlIENvbnN0cnVjdG9yUGFyYW1ldGVycyB3aGVuIHdlIGNhbiBzdXBwb3J0IFR5cGVzY3JpcHQgMy42XG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyIGV4dGVuZHMgVmFsdWUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMga2V5OiBzdHJpbmcsIHB1YmxpYyBmZXRjaFRpbWVNaWxsaXM6IG51bWJlciwgc291cmNlOiBmaXJlYmFzZS5yZW1vdGVDb25maWcuVmFsdWVTb3VyY2UsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzb3VyY2UsIHZhbHVlKTtcbiAgfVxufVxuXG4vLyBJZiBpdCdzIGEgUGFyYW1ldGVyIGFycmF5LCB0ZXN0IGFueSwgZWxzZSB0ZXN0IHRoZSBpbmRpdmlkdWFsIFBhcmFtZXRlclxuY29uc3QgZmlsdGVyVGVzdCA9IChmbjogKHBhcmFtOiBQYXJhbWV0ZXIpID0+IGJvb2xlYW4pID0+IGZpbHRlcjxQYXJhbWV0ZXIgfCBQYXJhbWV0ZXJbXT4oaXQgPT4gQXJyYXkuaXNBcnJheShpdCkgPyBpdC5zb21lKGZuKSA6IGZuKGl0KSk7XG5cbi8vIEFsbG93IHRoZSB1c2VyIHRvIGJ5cGFzcyB0aGUgZGVmYXVsdCB2YWx1ZXMgYW5kIHdhaXQgdGlsbCB0aGV5IGdldCBzb21ldGhpbmcgZnJvbSB0aGUgc2VydmVyLCBldmVuIGlmIGl0J3MgYSBjYWNoZWQgY29weTtcbi8vIGlmIHVzZWQgaW4gY29uanVudGlvbiB3aXRoIGZpcnN0KCkgaXQgd2lsbCBvbmx5IGZldGNoIFJDIHZhbHVlcyBmcm9tIHRoZSBzZXJ2ZXIgaWYgdGhleSBhcmVuJ3QgY2FjaGVkIGxvY2FsbHlcbmV4cG9ydCBjb25zdCBmaWx0ZXJSZW1vdGUgPSAoKSA9PiBmaWx0ZXJUZXN0KHAgPT4gcC5nZXRTb3VyY2UoKSA9PT0gJ3JlbW90ZScpO1xuXG4vLyBmaWx0ZXJGcmVzaCBhbGxvd3MgdGhlIGRldmVsb3BlciB0byBlZmZlY3RpdmVseSBzZXQgdXAgYSBtYXhpbXVtIGNhY2hlIHRpbWVcbmV4cG9ydCBjb25zdCBmaWx0ZXJGcmVzaCA9IChob3dSZWNlbnRJbk1pbGxpczogbnVtYmVyKSA9PiBmaWx0ZXJUZXN0KHAgPT4gcC5mZXRjaFRpbWVNaWxsaXMgKyBob3dSZWNlbnRJbk1pbGxpcyA+PSBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cblxuLy8gSSBkaXRjaGVkIGxvYWRpbmcgdGhlIGRlZmF1bHRzIGludG8gUkMgYW5kIGEgc2ltcGxlIG1hcCBmb3Igc2NhbiBzaW5jZSB3ZSBhbHJlYWR5IGhhdmUgb3VyIG93biBkZWZhdWx0cyBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoZSBpZGVhIGhlcmUgYmVpbmcgdGhhdCBpZiB0aGV5IGhhdmUgYSBkZWZhdWx0IHRoYXQgbmV2ZXIgbG9hZHMgZnJvbSB0aGUgc2VydmVyLCB0aGV5IHdpbGwgYmUgYWJsZSB0byB0ZWxsIHZpYSBmZXRjaFRpbWVNaWxsaXNcbi8vIG9uIHRoZSBQYXJhbWV0ZXIuIEFsc28gaWYgaXQgZG9lc24ndCBjb21lIGZyb20gdGhlIHNlcnZlciBpdCB3b24ndCBlbWl0IGFnYWluIGluIC5jaGFuZ2VzLCBkdWUgdG8gdGhlIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuLy8gd2hpY2ggd2UgY2FuIHNpbXBsaWZ5IHRvID09PSByYXRoZXIgdGhhbiBkZWVwIGNvbXBhcmlzb25cbmNvbnN0IHNjYW5Ub1BhcmFtZXRlcnNBcnJheSA9IChcbiAgcmVtb3RlQ29uZmlnOiBPYnNlcnZhYmxlPGZpcmViYXNlLnJlbW90ZUNvbmZpZy5SZW1vdGVDb25maWcgfCB1bmRlZmluZWQ+XG4pOiBPcGVyYXRvckZ1bmN0aW9uPHsgW2tleTogc3RyaW5nXTogZmlyZWJhc2UucmVtb3RlQ29uZmlnLlZhbHVlIH0sIFBhcmFtZXRlcltdPiA9PiBwaXBlKFxuICB3aXRoTGF0ZXN0RnJvbShyZW1vdGVDb25maWcpLFxuICBzY2FuKChleGlzdGluZywgW2FsbCwgcmNdKSA9PiB7XG4gICAgLy8gU0VNVkVSIHVzZSBcIm5ldyBTZXRcIiB0byB1bmlxdWUgb25jZSB3ZSdyZSBvbmx5IHRhcmdldGluZyBlczZcbiAgICAvLyBhdCB0aGUgc2NhbGUgd2UgZXhwZWN0IHJlbW90ZSBjb25maWcgdG8gYmUgYXQsIHdlIHByb2JhYmx5IHdvbid0IHNlZSBhIHBlcmZvcm1hbmNlIGhpdCBmcm9tIHRoaXMgdW5vcHRpbWl6ZWQgdW5pcXVlbmVzc1xuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIGNvbnN0IGFsbEtleXMgPSBbLi4ubmV3IFNldChbLi4uZXhpc3RpbmcubWFwKHAgPT4gcC5rZXkpLCAuLi5PYmplY3Qua2V5cyhhbGwpXSldO1xuICAgIGNvbnN0IGFsbEtleXMgPSBbLi4uZXhpc3RpbmcubWFwKHAgPT4gcC5rZXkpLCAuLi5PYmplY3Qua2V5cyhhbGwpXS5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG4gICAgcmV0dXJuIGFsbEtleXMubWFwKGtleSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkVmFsdWUgPSBhbGxba2V5XTtcbiAgICAgIHJldHVybiB1cGRhdGVkVmFsdWUgPyBuZXcgUGFyYW1ldGVyKGtleSwgcmMgPyByYy5mZXRjaFRpbWVNaWxsaXMgOiAtMSwgdXBkYXRlZFZhbHVlLmdldFNvdXJjZSgpLCB1cGRhdGVkVmFsdWUuYXNTdHJpbmcoKSlcbiAgICAgICAgOiBleGlzdGluZy5maW5kKHAgPT4gcC5rZXkgPT09IGtleSk7XG4gICAgfSk7XG4gIH0sIFtdIGFzIEFycmF5PFBhcmFtZXRlcj4pXG4pO1xuXG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ2FueSdcbn0pXG5leHBvcnQgY2xhc3MgQW5ndWxhckZpcmVSZW1vdGVDb25maWcge1xuXG4gIHJlYWRvbmx5IGNoYW5nZXM6IE9ic2VydmFibGU8UGFyYW1ldGVyPjtcbiAgcmVhZG9ubHkgcGFyYW1ldGVyczogT2JzZXJ2YWJsZTxQYXJhbWV0ZXJbXT47XG4gIHJlYWRvbmx5IG51bWJlcnM6IE9ic2VydmFibGU8eyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCB1bmRlZmluZWQgfT4gJiB7IFtrZXk6IHN0cmluZ106IE9ic2VydmFibGU8bnVtYmVyPiB9O1xuICByZWFkb25seSBib29sZWFuczogT2JzZXJ2YWJsZTx7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQgfT4gJiB7IFtrZXk6IHN0cmluZ106IE9ic2VydmFibGU8Ym9vbGVhbj4gfTtcbiAgcmVhZG9ubHkgc3RyaW5nczogT2JzZXJ2YWJsZTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9PiAmIHsgW2tleTogc3RyaW5nXTogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+IH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChGSVJFQkFTRV9PUFRJT05TKSBvcHRpb25zOiBGaXJlYmFzZU9wdGlvbnMsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChGSVJFQkFTRV9BUFBfTkFNRSkgbmFtZU9yQ29uZmlnOiBzdHJpbmcgfCBGaXJlYmFzZUFwcENvbmZpZyB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChTRVRUSU5HUykgc2V0dGluZ3M6IFNldHRpbmdzIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERFRkFVTFRTKSBkZWZhdWx0Q29uZmlnOiBDb25maWdUZW1wbGF0ZSB8IG51bGwsXG4gICAgcHJpdmF0ZSB6b25lOiBOZ1pvbmUsXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmJhbi10eXBlc1xuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHtcblxuICAgIGNvbnN0IHNjaGVkdWxlcnMgPSBuZXcgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMoem9uZSk7XG5cbiAgICBjb25zdCByZW1vdGVDb25maWckID0gb2YodW5kZWZpbmVkKS5waXBlKFxuICAgICAgb2JzZXJ2ZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgc3dpdGNoTWFwKCgpID0+IGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpID8gaW1wb3J0KCdmaXJlYmFzZS9yZW1vdGUtY29uZmlnJykgOiBFTVBUWSksXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gaW1wb3J0KCdAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZycpKSxcbiAgICAgIHRhcChyYyA9PiByYy5yZWdpc3RlclJlbW90ZUNvbmZpZyAmJiByYy5yZWdpc3RlclJlbW90ZUNvbmZpZyhmaXJlYmFzZSBhcyBhbnkpKSxcbiAgICAgIG1hcCgoKSA9PiDJtWZpcmViYXNlQXBwRmFjdG9yeShvcHRpb25zLCB6b25lLCBuYW1lT3JDb25maWcpKSxcbiAgICAgIG1hcChhcHAgPT4gybVmZXRjaEluc3RhbmNlKGAke2FwcC5uYW1lfS5yZW1vdGUtY29uZmlnYCwgJ0FuZ3VsYXJGaXJlUmVtb3RlQ29uZmlnJywgYXBwLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJjID0gYXBwLnJlbW90ZUNvbmZpZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICByYy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgICAgcmMuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJjO1xuICAgICAgfSwgW3NldHRpbmdzLCBkZWZhdWx0Q29uZmlnXSkpLFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICBzdGFydFdpdGgodW5kZWZpbmVkKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IGZhbHNlIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGxvYWRlZFJlbW90ZUNvbmZpZyQgPSByZW1vdGVDb25maWckLnBpcGUoXG4gICAgICBmaWx0ZXI8ZmlyZWJhc2UucmVtb3RlQ29uZmlnLlJlbW90ZUNvbmZpZz4ocmMgPT4gISFyYylcbiAgICApO1xuXG4gICAgY29uc3QgZGVmYXVsdCQ6IE9ic2VydmFibGU8eyBba2V5OiBzdHJpbmddOiBmaXJlYmFzZS5yZW1vdGVDb25maWcuVmFsdWUgfT4gPSBvZihPYmplY3Qua2V5cyhkZWZhdWx0Q29uZmlnIHx8IHt9KS5yZWR1Y2UoXG4gICAgICAoYywgaykgPT4gKHsgLi4uYywgW2tdOiBuZXcgVmFsdWUoJ2RlZmF1bHQnLCBkZWZhdWx0Q29uZmlnW2tdLnRvU3RyaW5nKCkpIH0pLCB7fVxuICAgICkpO1xuXG4gICAgLy8gd2Ugc2hvdWxkIGZpbHRlciBvdXQgdGhlIGRlZmF1bHRzIHdlIHByb3ZpZGVkIHRvIFJDLCBzaW5jZSB3ZSBoYXZlIG91ciBvd24gaW1wbGVtZW50YXRpb25cbiAgICAvLyB0aGF0IGdpdmVzIHVzIGEgLTEgZm9yIGZldGNoVGltZU1pbGxpcyAoc28gZmlsdGVyRnJlc2ggY2FuIGZpbHRlciB0aGVtIG91dClcbiAgICBjb25zdCBmaWx0ZXJPdXREZWZhdWx0cyA9IG1hcDx7IFtrZXk6IHN0cmluZ106IGZpcmViYXNlLnJlbW90ZUNvbmZpZy5WYWx1ZSB9LCB7IFtrZXk6IHN0cmluZ106IGZpcmViYXNlLnJlbW90ZUNvbmZpZy5WYWx1ZSB9PihhbGwgPT5cbiAgICAgIE9iamVjdC5rZXlzKGFsbClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gYWxsW2tleV0uZ2V0U291cmNlKCkgIT09ICdkZWZhdWx0JylcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGFsbFtrZXldIH0pLCB7fSlcbiAgICApO1xuXG4gICAgY29uc3QgZXhpc3RpbmckID0gbG9hZGVkUmVtb3RlQ29uZmlnJC5waXBlKFxuICAgICAgc3dpdGNoTWFwKHJjID0+XG4gICAgICAgIHJjLmFjdGl2YXRlKClcbiAgICAgICAgICAudGhlbigoKSA9PiByYy5lbnN1cmVJbml0aWFsaXplZCgpKVxuICAgICAgICAgIC50aGVuKCgpID0+IHJjLmdldEFsbCgpKVxuICAgICAgKSxcbiAgICAgIGZpbHRlck91dERlZmF1bHRzXG4gICAgKTtcblxuICAgIGNvbnN0IGZyZXNoJCA9IGxvYWRlZFJlbW90ZUNvbmZpZyQucGlwZShcbiAgICAgIHN3aXRjaE1hcChyYyA9PiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgIHJjLmZldGNoQW5kQWN0aXZhdGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHJjLmVuc3VyZUluaXRpYWxpemVkKCkpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gcmMuZ2V0QWxsKCkpXG4gICAgICApKSxcbiAgICAgIGZpbHRlck91dERlZmF1bHRzXG4gICAgKTtcblxuICAgIHRoaXMucGFyYW1ldGVycyA9IGNvbmNhdChkZWZhdWx0JCwgZXhpc3RpbmckLCBmcmVzaCQpLnBpcGUoXG4gICAgICBzY2FuVG9QYXJhbWV0ZXJzQXJyYXkocmVtb3RlQ29uZmlnJCksXG4gICAgICDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KHNjaGVkdWxlcnMpLFxuICAgICAgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KVxuICAgICk7XG5cbiAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLnBhcmFtZXRlcnMucGlwZShcbiAgICAgIHN3aXRjaE1hcChwYXJhbXMgPT4gb2YoLi4ucGFyYW1zKSksXG4gICAgICBncm91cEJ5KHBhcmFtID0+IHBhcmFtLmtleSksXG4gICAgICBtZXJnZU1hcChncm91cCA9PiBncm91cC5waXBlKFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApKVxuICAgICk7XG5cbiAgICB0aGlzLnN0cmluZ3MgPSBwcm94eUFsbCh0aGlzLnBhcmFtZXRlcnMsICdzdHJpbmdzJyk7XG4gICAgdGhpcy5ib29sZWFucyA9IHByb3h5QWxsKHRoaXMucGFyYW1ldGVycywgJ2Jvb2xlYW5zJyk7XG4gICAgdGhpcy5udW1iZXJzID0gcHJveHlBbGwodGhpcy5wYXJhbWV0ZXJzLCAnbnVtYmVycycpO1xuXG4gICAgcmV0dXJuIMm1bGF6eVNES1Byb3h5KHRoaXMsIGxvYWRlZFJlbW90ZUNvbmZpZyQsIHpvbmUpO1xuICB9XG5cbn1cblxuXG5leHBvcnQgY29uc3QgYnVkZ2V0ID0gPFQ+KGludGVydmFsOiBudW1iZXIpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VD4gPT4gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gbmV3IE9ic2VydmFibGU8VD4ob2JzZXJ2ZXIgPT4ge1xuICBsZXQgdGltZWRPdXQgPSBmYWxzZTtcbiAgLy8gVE9ETyB1c2Ugc2NoZWR1bGVyIHRhc2sgcmF0aGVyIHRoYW4gc2V0dGltZW91dFxuICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB0aW1lZE91dCA9IHRydWU7XG4gIH0sIGludGVydmFsKTtcbiAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xuICAgIG5leHQodmFsKSB7XG4gICAgICBpZiAoIXRpbWVkT3V0KSB7XG4gICAgICAgIG9ic2VydmVyLm5leHQodmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVycm9yKGVycikge1xuICAgICAgaWYgKCF0aW1lZE91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgIGlmICghdGltZWRPdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KTtcblxuY29uc3QgdHlwZWRNZXRob2QgPSAoaXQ6IGFueSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBpdCkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJ2FzU3RyaW5nJztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAnYXNCb29sZWFuJztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuICdhc051bWJlcic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnYXNTdHJpbmcnO1xuICB9XG59O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FuVG9PYmplY3QoKTogT3BlcmF0b3JGdW5jdGlvbjxQYXJhbWV0ZXIsIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Ub09iamVjdCh0bzogJ251bWJlcnMnKTogT3BlcmF0b3JGdW5jdGlvbjxQYXJhbWV0ZXIsIHsgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Ub09iamVjdCh0bzogJ2Jvb2xlYW5zJyk6IE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyLCB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQgfT47XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dW5pZmllZC1zaWduYXR1cmVzXG5leHBvcnQgZnVuY3Rpb24gc2NhblRvT2JqZWN0KHRvOiAnc3RyaW5ncycpOiBPcGVyYXRvckZ1bmN0aW9uPFBhcmFtZXRlciwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfT47XG5leHBvcnQgZnVuY3Rpb24gc2NhblRvT2JqZWN0PFQgZXh0ZW5kcyBDb25maWdUZW1wbGF0ZT4odGVtcGxhdGU6IFQpOiBPcGVyYXRvckZ1bmN0aW9uPFBhcmFtZXRlciwgVCAmIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW5Ub09iamVjdDxUIGV4dGVuZHMgQ29uZmlnVGVtcGxhdGU+KHRvOiAnbnVtYmVycycgfCAnYm9vbGVhbnMnIHwgJ3N0cmluZ3MnIHwgVCA9ICdzdHJpbmdzJykge1xuICByZXR1cm4gcGlwZShcbiAgICAvLyBUT0RPIGNsZWFudXBcbiAgICBzY2FuKFxuICAgICAgKGMsIHA6IFBhcmFtZXRlcikgPT4gKHtcbiAgICAgICAgLi4uYywgW3Aua2V5XTogdHlwZW9mIHRvID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgcFt0eXBlZE1ldGhvZCh0b1twLmtleV0pXSgpIDpcbiAgICAgICAgICBwW0FTX1RPX0ZOW3RvXV0oKVxuICAgICAgfSksXG4gICAgICB0eXBlb2YgdG8gPT09ICdvYmplY3QnID9cbiAgICAgICAgdG8gYXMgVCAmIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gOlxuICAgICAgICB7fSBhcyB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmcgfVxuICAgICksXG4gICAgZGVib3VuY2VUaW1lKDEpLFxuICAgIGJ1ZGdldCgxMCksXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKGEsIGIpID0+IEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvT2JqZWN0KCk6IE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyW10sIHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0+O1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvT2JqZWN0KHRvOiAnbnVtYmVycycpOiBPcGVyYXRvckZ1bmN0aW9uPFBhcmFtZXRlcltdLCB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IHVuZGVmaW5lZCB9PjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb09iamVjdCh0bzogJ2Jvb2xlYW5zJyk6IE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyW10sIHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB8IHVuZGVmaW5lZCB9Pjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1bmlmaWVkLXNpZ25hdHVyZXNcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb09iamVjdCh0bzogJ3N0cmluZ3MnKTogT3BlcmF0b3JGdW5jdGlvbjxQYXJhbWV0ZXJbXSwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfT47XG5leHBvcnQgZnVuY3Rpb24gbWFwVG9PYmplY3Q8VCBleHRlbmRzIENvbmZpZ1RlbXBsYXRlPih0ZW1wbGF0ZTogVCk6XG4gIE9wZXJhdG9yRnVuY3Rpb248UGFyYW1ldGVyW10sIFQgJiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9PjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBUb09iamVjdDxUIGV4dGVuZHMgQ29uZmlnVGVtcGxhdGU+KHRvOiAnbnVtYmVycycgfCAnYm9vbGVhbnMnIHwgJ3N0cmluZ3MnIHwgVCA9ICdzdHJpbmdzJykge1xuICByZXR1cm4gcGlwZShcbiAgICAvLyBUT0RPIHRoaXMgaXMgZ2V0dGluZyBhIGxpdHRsZSBsb25nLCBjbGVhbnVwXG4gICAgbWFwKChwYXJhbXM6IFBhcmFtZXRlcltdKSA9PiBwYXJhbXMucmVkdWNlKFxuICAgICAgKGMsIHApID0+ICh7XG4gICAgICAgIC4uLmMsIFtwLmtleV06IHR5cGVvZiB0byA9PT0gJ29iamVjdCcgP1xuICAgICAgICAgIHBbdHlwZWRNZXRob2QodG9bcC5rZXldKV0oKSA6XG4gICAgICAgICAgcFtBU19UT19GTlt0b11dKClcbiAgICAgIH0pLFxuICAgICAgdHlwZW9mIHRvID09PSAnb2JqZWN0JyA/XG4gICAgICAgIHRvIGFzIFQgJiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9IDpcbiAgICAgICAge30gYXMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBib29sZWFuIHwgc3RyaW5nIH1cbiAgICApKSxcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgoYSwgYikgPT4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpKVxuICApO1xufVxuXG7JtWFwcGx5TWl4aW5zKEFuZ3VsYXJGaXJlUmVtb3RlQ29uZmlnLCBbcHJveHlQb2x5ZmlsbENvbXBhdF0pO1xuIl19